<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Skin Scanner</title>
    <!-- TensorFlow.js and Models -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.18.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet@2.1.0/dist/mobilenet.min.js"></script>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <h1>AI Skin Scanner</h1>
        <p>Scan your skin for possible concerns</p>
    </header>
    
    <main>
        <div class="container">
            <div class="card">
                <div class="disclaimer">
                    <h3>Important Medical Disclaimer</h3>
                    <p>This application is for educational purposes only and is not a substitute for professional medical advice, diagnosis, or treatment. Always seek the advice of your physician or other qualified health provider with any questions you may have regarding a medical condition.</p>
                </div>
                
                <h2>Scan Your Skin</h2>
                <p>Take a clear photo of the skin area you're concerned about. Position the area inside the circle.</p>
                
                <div class="camera-container">
                    <video id="video" autoplay playsinline></video>
                    <canvas id="canvas"></canvas>
                    <canvas id="tensorflowCanvas"></canvas>
                    <img id="photo" alt="Captured skin photo">
                    
                    <div class="camera-overlay" id="cameraOverlay">
                        <div class="camera-target"></div>
                        <div class="camera-guide">Position skin concern in the circle</div>
                    </div>
                </div>
                
                <div class="controls">
                    <button id="startCamera">Start Camera</button>
                    <button id="capturePhoto" disabled>Take Photo</button>
                    <button id="analyzePhoto" class="success" disabled>Analyze</button>
                    <button id="resetCamera" class="secondary" disabled>Reset</button>
                </div>
                
                <div class="loading" id="loadingAnalysis">
                    <div class="spinner"></div>
                    <p>Analyzing your skin image...</p>
                </div>
                
                <div class="analysis-result" id="analysisResult">
                    <div class="result-icon" id="resultIcon">⚠️</div>
                    <h3 class="result-message" id="resultMessage">Analysis Complete</h3>
                    
                    <div style="text-align: center; margin: 1rem 0;">
                        <div style="display: inline-block; padding: 0.5rem 1.5rem; border-radius: 20px; background-color: #f1c40f; color: white; font-weight: bold;">
                            <span id="confidenceScore">75</span>% AI Confidence
                        </div>
                    </div>
                    
                    <div class="result-details">
                        <div class="result-item">
                            <strong>Concern Level:</strong>
                            <span id="concernLevel">Medium</span>
                        </div>
                        <div class="result-item">
                            <strong>Possible Condition:</strong>
                            <span id="possibleCondition">Analyzing...</span>
                        </div>
                        <div class="result-item">
                            <strong>Recommendation:</strong>
                            <span id="recommendation">Consult with a dermatologist</span>
                        </div>
                        <div class="result-item">
                            <strong>Time Frame:</strong>
                            <span id="timeFrame">Within the next 2 weeks</span>
                        </div>
                        <div class="result-item">
                            <strong>Data Source:</strong>
                            <span>TensorFlow + ISIC Archive API</span>
                        </div>
                    </div>
                    
                    <div style="margin-top: 1.5rem; border: 1px solid #ddd; border-radius: 8px; overflow: hidden;">
                        <div style="background-color: #f5f5f5; padding: 0.8rem; border-bottom: 1px solid #ddd;">
                            <strong>ABCDE Analysis</strong>
                        </div>
                        <div style="padding: 1rem;">
                            <div id="abcdeFeatures">
                                <div class="result-item">
                                    <strong>A - Asymmetry:</strong>
                                    <span id="asymmetryResult">Analyzing...</span>
                                </div>
                                <div class="result-item">
                                    <strong>B - Border:</strong>
                                    <span id="borderResult">Analyzing...</span>
                                </div>
                                <div class="result-item">
                                    <strong>C - Color:</strong>
                                    <span id="colorResult">Analyzing...</span>
                                </div>
                                <div class="result-item">
                                    <strong>D - Diameter:</strong>
                                    <span id="diameterResult">Analyzing...</span>
                                </div>
                                <div class="result-item">
                                    <strong>E - Evolution:</strong>
                                    <span>Cannot be determined from a single image</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <h4 style="margin-top: 1.5rem;">Similar Cases from ISIC Archive:</h4>
                    <div class="results-gallery" id="similarImages">
                        <!-- Similar images will be inserted here -->
                    </div>
                    
                    <div class="disclaimer">
                        <h3>Important:</h3>
                        <p>This analysis uses TensorFlow.js and references the ISIC Archive database but is a demonstration only. Real skin conditions require proper medical evaluation by a healthcare professional. The ABCDE method (Asymmetry, Border, Color, Diameter, Evolution) is a standard approach for evaluating skin lesions.</p>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="footer">
            <p>This prototype references the <a href="https://api.isic-archive.com/">ISIC Archive</a>. Not for actual medical use.</p>
        </div>
    </main>

    <script>
        // DOM elements
        const startButton = document.getElementById('startCamera');
        const captureButton = document.getElementById('capturePhoto');
        const analyzeButton = document.getElementById('analyzePhoto');
        const resetButton = document.getElementById('resetCamera');
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const tensorflowCanvas = document.getElementById('tensorflowCanvas');
        const photo = document.getElementById('photo');
        const cameraOverlay = document.getElementById('cameraOverlay');
        const loadingAnalysis = document.getElementById('loadingAnalysis');
        const analysisResult = document.getElementById('analysisResult');
        const resultIcon = document.getElementById('resultIcon');
        const resultMessage = document.getElementById('resultMessage');
        const concernLevel = document.getElementById('concernLevel');
        const recommendation = document.getElementById('recommendation');
        const timeFrame = document.getElementById('timeFrame');
        const detectedFeatures = document.getElementById('detectedFeatures');
        const similarImages = document.getElementById('similarImages');
        
        // Stream reference
        let stream = null;
        
        // TensorFlow models
        let mobileNetModel = null;
        let customModel = null;
        
        // Model loading status
        let modelLoadingStatus = {
            mobileNet: false,
            customModel: false
        };
        
        // ISIC API Configuration
        const ISIC_API_BASE = 'https://api.isic-archive.com/api/v2';
        
        // Common conditions to search for with ABCDE criteria
        const SKIN_CONDITIONS = [
            { 
                term: 'melanoma', 
                risk: 'high', 
                features: ['asymmetry', 'irregular border', 'color variation', 'diameter > 6mm', 'evolving'],
                abcde: {
                    a: 'Asymmetric shape - one half unlike the other',
                    b: 'Border irregular or poorly defined',
                    c: 'Color varies from one area to another',
                    d: 'Diameter larger than 6mm (pencil eraser)',
                    e: 'Evolving size, shape, or color'
                },
                keyVisualTerms: ['irregular', 'asymmetric', 'dark', 'black', 'blue', 'red', 'uneven', 'jagged']
            },
            { 
                term: 'nevus', 
                risk: 'low', 
                features: ['symmetrical', 'regular border', 'uniform color', 'usually < 6mm'],
                abcde: {
                    a: 'Symmetric shape',
                    b: 'Border regular and well-defined',
                    c: 'Color uniform throughout',
                    d: 'Diameter usually less than 6mm',
                    e: 'Not evolving; stable over time'
                },
                keyVisualTerms: ['round', 'symmetric', 'brown', 'tan', 'even', 'smooth', 'regular', 'small']
            },
            { 
                term: 'basal cell carcinoma', 
                risk: 'medium', 
                features: ['translucent', 'ulcerated', 'rolled border', 'pearly appearance'],
                abcde: {
                    a: 'Often symmetric but can vary',
                    b: 'Rolled, pearly borders',
                    c: 'Often flesh-colored or pink',
                    d: 'Various sizes',
                    e: 'Grows slowly over time'
                },
                keyVisualTerms: ['shiny', 'pearly', 'translucent', 'pink', 'red', 'ulcer', 'wound', 'raised']
            },
            { 
                term: 'squamous cell carcinoma', 
                risk: 'medium', 
                features: ['scaly', 'crusty', 'red patches', 'sometimes bleeding'],
                abcde: {
                    a: 'Often irregularly shaped',
                    b: 'Irregular borders',
                    c: 'Red, pink, or skin-colored',
                    d: 'Various sizes',
                    e: 'Usually grows faster than basal cell'
                },
                keyVisualTerms: ['scaly', 'rough', 'crusty', 'red', 'inflamed', 'firm', 'raised', 'patchy']
            },
            { 
                term: 'seborrheic keratosis', 
                risk: 'low', 
                features: ['waxy', 'stuck-on appearance', 'light to brown color', 'warty texture'],
                abcde: {
                    a: 'Usually symmetric',
                    b: 'Sharp borders, stuck-on appearance',
                    c: 'Light tan to black, often uniform',
                    d: 'Various sizes',
                    e: 'Stable over time, may darken'
                },
                keyVisualTerms: ['waxy', 'stuck-on', 'rough', 'warty', 'brown', 'dark', 'raised', 'old']
            }
        ];
        
        // Load TensorFlow models when page loads
        async function loadModels() {
            try {
                // Show loading message
                const loadingMessage = document.createElement('div');
                loadingMessage.style.position = 'fixed';
                loadingMessage.style.top = '0';
                loadingMessage.style.left = '0';
                loadingMessage.style.right = '0';
                loadingMessage.style.backgroundColor = 'rgba(52, 152, 219, 0.8)';
                loadingMessage.style.color = 'white';
                loadingMessage.style.padding = '10px';
                loadingMessage.style.textAlign = 'center';
                loadingMessage.style.zIndex = '1000';
                loadingMessage.textContent = 'Loading AI models...';
                document.body.appendChild(loadingMessage);
                
                // Load MobileNet for feature extraction
                console.log('Loading MobileNet model...');
                mobileNetModel = await mobilenet.load();
                console.log('MobileNet model loaded');
                modelLoadingStatus.mobileNet = true;
                
                // Load custom skin-specific model (simulated in this demo)
                // In a real app, you would load a custom TensorFlow.js model trained on skin lesions
                console.log('Initializing skin analysis model...');
                await new Promise(resolve => setTimeout(resolve, 1500)); // Simulate loading time
                modelLoadingStatus.customModel = true;
                console.log('Skin analysis model ready');
                
                // Enable the start camera button
                startButton.disabled = false;
                
                // Update loading message
                loadingMessage.textContent = 'AI models loaded successfully!';
                setTimeout(() => {
                    loadingMessage.style.opacity = '0';
                    loadingMessage.style.transition = 'opacity 0.5s';
                    setTimeout(() => loadingMessage.remove(), 500);
                }, 1500);
                
            } catch (error) {
                console.error('Error loading models:', error);
                alert('There was a problem loading the AI models. The app will use limited functionality.');
                
                // Still enable the camera button even if model loading fails
                startButton.disabled = false;
            }
        }
        
        // Initialize models
        startButton.disabled = true;
        loadModels();
        
        // Function to fetch data from ISIC API
        async function fetchFromISIC(endpoint, params = {}) {
            try {
                // Build query string
                const queryParams = new URLSearchParams(params);
                const url = `${ISIC_API_BASE}${endpoint}?${queryParams}`;
                
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`ISIC API error: ${response.status}`);
                }
                
                return await response.json();
            } catch (error) {
                console.error('Error fetching from ISIC API:', error);
                return null;
            }
        }
        
        // Function to search for similar lesions
        async function searchSimilarLesions(diagnosis) {
            const params = {
                query: `diagnosis:${diagnosis}`,
                limit: 5
            };
            
            return await fetchFromISIC('/images/search/', params);
        }
        
        // Function to extract skin image features
        async function analyzeImage(imgElement) {
            if (!mobileNetModel) {
                console.warn('MobileNet model not loaded yet');
                return { features: null, colorAnalysis: null };
            }
            
            try {
                // Prepare canvas for TensorFlow
                tensorflowCanvas.width = imgElement.width;
                tensorflowCanvas.height = imgElement.height;
                const ctx = tensorflowCanvas.getContext('2d');
                ctx.drawImage(imgElement, 0, 0, tensorflowCanvas.width, tensorflowCanvas.height);
                
                // Classify the image using MobileNet
                const classificationResults = await mobileNetModel.classify(tensorflowCanvas);
                
                // Extract color information
                const colorAnalysis = analyzeColors(tensorflowCanvas);
                
                // Extract image features (asymmetry, border regularity, etc.)
                const shapeFeatures = analyzeShape(tensorflowCanvas);
                
                return {
                    classifications: classificationResults,
                    colorAnalysis,
                    shapeFeatures
                };
            } catch (error) {
                console.error('Error analyzing image:', error);
                return { classifications: null, colorAnalysis: null, shapeFeatures: null };
            }
        }
        
        // Function to analyze image colors
        function analyzeColors(canvas) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Colors to track (RGB values)
            const colors = {
                red: { count: 0, threshold: [150, 50, 50] },
                brown: { count: 0, threshold: [120, 70, 40] },
                black: { count: 0, threshold: [50, 50, 50] },
                blue: { count: 0, threshold: [50, 50, 150] },
                white: { count: 0, threshold: [200, 200, 200] },
                pink: { count: 0, threshold: [230, 150, 150] }
            };
            
            // Counters for analysis
            let pixelCount = 0;
            let colorVariance = 0;
            let previousR = 0, previousG = 0, previousB = 0;
            
            // Analyze every 10th pixel (for performance)
            for (let i = 0; i < data.length; i += 40) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                
                // Skip transparent pixels
                if (data[i + 3] < 128) continue;
                
                pixelCount++;
                
                // Track color variance
                if (pixelCount > 1) {
                    const variance = Math.abs(r - previousR) + Math.abs(g - previousG) + Math.abs(b - previousB);
                    colorVariance += variance;
                }
                
                previousR = r;
                previousG = g;
                previousB = b;
                
                // Check if pixel matches each color category
                for (const [color, info] of Object.entries(colors)) {
                    const [thresholdR, thresholdG, thresholdB] = info.threshold;
                    
                    // Simple color matching logic
                    switch (color) {
                        case 'red':
                            if (r > thresholdR && g < thresholdG && b < thresholdB) colors.red.count++;
                            break;
                        case 'brown':
                            if (r > thresholdR && g < thresholdG && b < thresholdB) colors.brown.count++;
                            break;
                        case 'black':
                            if (r < thresholdR && g < thresholdG && b < thresholdB) colors.black.count++;
                            break;
                        case 'blue':
                            if (r < thresholdR && g < thresholdG && b > thresholdB) colors.blue.count++;
                            break;
                        case 'white':
                            if (r > thresholdR && g > thresholdG && b > thresholdB) colors.white.count++;
                            break;
                        case 'pink':
                            if (r > thresholdR && g > 100 && g < 200 && b > 100 && b < 200) colors.pink.count++;
                            break;
                    }
                }
            }
            
            // Calculate percentages
            for (const color in colors) {
                colors[color].percentage = (colors[color].count / pixelCount) * 100;
            }
            
            // Normalize color variance
            const avgColorVariance = colorVariance / pixelCount;
            
            // Determine dominant colors (top 2)
            const sortedColors = Object.entries(colors)
                .map(([color, info]) => ({ color, percentage: info.percentage }))
                .sort((a, b) => b.percentage - a.percentage);
            
            return {
                dominantColors: sortedColors.slice(0, 2),
                colorVariance: avgColorVariance,
                colorVarianceLevel: avgColorVariance > 20 ? 'high' : (avgColorVariance > 10 ? 'medium' : 'low'),
                hasMultipleColors: avgColorVariance > 15
            };
        }
        
        // Function to analyze shape features
        function analyzeShape(canvas) {
            // In a real app, this would use computer vision algorithms
            // For this demo, we'll return simulated results
            
            // Simulate border irregularity detection
            const borderIrregularity = Math.random();
            
            // Simulate asymmetry detection
            const asymmetryScore = Math.random();
            
            // Simulate diameter estimation (in mm)
            // Assumes a typical lesion size range of 2-15mm
            const estimatedDiameter = 2 + Math.random() * 13;
            
            return {
                borderRegularity: borderIrregularity < 0.5 ? 'regular' : 'irregular',
                asymmetry: asymmetryScore < 0.5 ? 'symmetric' : 'asymmetric',
                estimatedDiameter: estimatedDiameter.toFixed(1),
                diameterConcern: estimatedDiameter > 6
            };
        }
        
        // Function to map image analysis results to skin conditions
        function determineSkinCondition(analysisResults) {
            if (!analysisResults || !analysisResults.classifications) {
                return SKIN_CONDITIONS[Math.floor(Math.random() * SKIN_CONDITIONS.length)];
            }
            
            const { classifications, colorAnalysis, shapeFeatures } = analysisResults;
            
            // Create a scoring system for each condition
            const scores = {};
            SKIN_CONDITIONS.forEach(condition => {
                scores[condition.term] = 0;
            });
            
            // 1. Score based on MobileNet classifications
            if (classifications) {
                classifications.forEach(classification => {
                    const className = classification.className.toLowerCase();
                    const probability = classification.probability;
                    
                    // Check each condition's visual terms against the classification
                    SKIN_CONDITIONS.forEach(condition => {
                        condition.keyVisualTerms.forEach(term => {
                            if (className.includes(term)) {
                                scores[condition.term] += probability * 2;
                            }
                        });
                    });
                });
            }
            
            // 2. Score based on color analysis
            if (colorAnalysis) {
                // Melanoma often has color variation
                if (colorAnalysis.colorVarianceLevel === 'high') {
                    scores['melanoma'] += 2;
                }
                
                // Check dominant colors
                colorAnalysis.dominantColors.forEach(({ color, percentage }) => {
                    if (percentage > 20) {
                        switch (color) {
                            case 'red':
                                scores['basal cell carcinoma'] += 1;
                                scores['squamous cell carcinoma'] += 1.5;
                                break;
                            case 'brown':
                                scores['nevus'] += 1;
                                scores['seborrheic keratosis'] += 1;
                                break;
                            case 'black':
                                scores['melanoma'] += 2;
                                break;
                            case 'blue':
                                scores['melanoma'] += 1.5;
                                break;
                            case 'pink':
                                scores['basal cell carcinoma'] += 1.5;
                                break;
                        }
                    }
                });
                
                // Multiple colors indicate melanoma
                if (colorAnalysis.hasMultipleColors) {
                    scores['melanoma'] += 1.5;
                }
            }
            
            // 3. Score based on shape features
            if (shapeFeatures) {
                // Border irregularity
                if (shapeFeatures.borderRegularity === 'irregular') {
                    scores['melanoma'] += 2;
                    scores['squamous cell carcinoma'] += 0.5;
                } else {
                    scores['nevus'] += 1;
                    scores['seborrheic keratosis'] += 0.5;
                }
                
                // Asymmetry
                if (shapeFeatures.asymmetry === 'asymmetric') {
                    scores['melanoma'] += 2;
                } else {
                    scores['nevus'] += 1;
                    scores['seborrheic keratosis'] += 0.5;
                }
                
                // Diameter > 6mm is concerning for melanoma
                if (shapeFeatures.diameterConcern) {
                    scores['melanoma'] += 1.5;
                }
            }
            
            // Find the condition with the highest score
            let topScore = 0;
            let topCondition = null;
            
            for (const [condition, score] of Object.entries(scores)) {
                if (score > topScore) {
                    topScore = score;
                    topCondition = SKIN_CONDITIONS.find(c => c.term === condition);
                }
            }
            
            // If no clear winner or very low scores, pick a random condition
            // (In production, you would want a more sophisticated approach)
            if (!topCondition || topScore < 1) {
                topCondition = SKIN_CONDITIONS[Math.floor(Math.random() * SKIN_CONDITIONS.length)];
                topScore = 1;
            }
            
            // Calculate confidence level (0-100%)
            const confidence = Math.min(Math.max(topScore * 10, 30), 95);
            
            return {
                condition: topCondition,
                confidence,
                scores,
                analysisNotes: {
                    colorVariation: colorAnalysis ? colorAnalysis.colorVarianceLevel : 'unknown',
                    border: shapeFeatures ? shapeFeatures.borderRegularity : 'unknown',
                    symmetry: shapeFeatures ? shapeFeatures.asymmetry : 'unknown',
                    diameter: shapeFeatures ? `~${shapeFeatures.estimatedDiameter}mm` : 'unknown'
                }
            };
        }
        
        // Function to display similar images from ISIC
        function displaySimilarImages(results) {
            similarImages.innerHTML = '';
            
            if (!results || !results.results || results.results.length === 0) {
                const noResults = document.createElement('p');
                noResults.textContent = 'No similar images found';
                similarImages.appendChild(noResults);
                return;
            }
            
            // Add similar images to the gallery
            results.results.forEach(image => {
                if (image.files && image.files.thumbnail_256) {
                    const img = document.createElement('img');
                    img.src = image.files.thumbnail_256.url;
                    img.className = 'similar-image';
                    img.alt = 'Similar case';
                    img.title = image.metadata?.diagnosis || 'Similar case';
                    similarImages.appendChild(img);
                }
            });
        }
        
        // Start camera
        startButton.addEventListener('click', async () => {
            try {
                stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'environment',
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    },
                    audio: false
                });
                
                video.srcObject = stream;
                video.style.display = 'block';
                photo.style.display = 'none';
                startButton.disabled = true;
                captureButton.disabled = false;
                resetButton.disabled = false;
                analyzeButton.disabled = true;
            } catch (err) {
                console.error('Error accessing camera:', err);
                alert('Unable to access camera. Please ensure you have given permission and that your device has a camera.');
            }
        });
        
        // Capture photo
        captureButton.addEventListener('click', () => {
            // Set canvas dimensions to match video
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            
            // Draw the video frame to the canvas
            const context = canvas.getContext('2d');
            context.drawImage(video, 0, 0, canvas.width, canvas.height);
            
            // Convert to data URL and display the captured photo
            const dataUrl = canvas.toDataURL('image/png');
            photo.src = dataUrl;
            
            // Hide video, show photo
            video.style.display = 'none';
            photo.style.display = 'block';
            cameraOverlay.style.display = 'none';
            
            // Update button states
            captureButton.disabled = true;
            analyzeButton.disabled = false;
        });
        
        // Reset camera
        resetButton.addEventListener('click', () => {
            // Stop the stream if it exists
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
            }
            
            // Reset UI
            video.srcObject = null;
            photo.src = '';
            video.style.display = 'block';
            photo.style.display = 'none';
            cameraOverlay.style.display = 'flex';
            analysisResult.style.display = 'none';
            similarImages.innerHTML = '';
            
            // Reset button states
            startButton.disabled = false;
            captureButton.disabled = true;
            analyzeButton.disabled = true;
            resetButton.disabled = true;
        });
        
        // Analyze photo using TensorFlow and ISIC API
        analyzeButton.addEventListener('click', async () => {
            // Show loading
            loadingAnalysis.style.display = 'block';
            analyzeButton.disabled = true;
            
            try {
                // Analyze the image with TensorFlow
                const analysisResults = await analyzeImage(photo);
                console.log('Image analysis results:', analysisResults);
                
                // Determine the most likely skin condition
                const result = determineSkinCondition(analysisResults);
                console.log('Skin condition assessment:', result);
                
                // Get the detected condition
                const { condition, confidence, analysisNotes } = result;
                
                // Fetch similar images from ISIC
                const searchResults = await searchSimilarLesions(condition.term);
                console.log('ISIC search results:', searchResults);
                
                // Display similar images
                displaySimilarImages(searchResults);
                
                // Prepare result display based on the condition
                let displayResult;
                if (condition.risk === 'high') {
                    displayResult = {
                        icon: '🚨',
                        message: `High Risk - Possible ${condition.term}`,
                        concern: 'High',
                        concernClass: 'risk-high',
                        recommendation: 'Seek medical attention',
                        timeFrame: 'As soon as possible'
                    };
                } else if (condition.risk === 'medium') {
                    displayResult = {
                        icon: '⚠️',
                        message: `Medium Risk - Possible ${condition.term}`,
                        concern: 'Medium',
                        concernClass: 'risk-medium',
                        recommendation: 'Consult with a dermatologist',
                        timeFrame: 'Within the next 2 weeks'
                    };
                } else {
                    displayResult = {
                        icon: '✅',
                        message: `Low Risk - Possible ${condition.term}`,
                        concern: 'Low',
                        concernClass: 'risk-low',
                        recommendation: 'Monitor for changes',
                        timeFrame: 'No immediate action needed'
                    };
                }
                
                // Format condition name for display (capitalize first letter of each word)
                const formattedCondition = condition.term
                    .split(' ')
                    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                    .join(' ');
                
                // Update main result display
                resultIcon.textContent = displayResult.icon;
                resultMessage.textContent = displayResult.message;
                concernLevel.textContent = displayResult.concern;
                concernLevel.className = displayResult.concernClass;
                recommendation.textContent = displayResult.recommendation;
                timeFrame.textContent = displayResult.timeFrame;
                
                // Update confidence score
                document.getElementById('confidenceScore').textContent = Math.round(confidence);
                
                // Update possible condition
                document.getElementById('possibleCondition').textContent = formattedCondition;
                
                // Update ABCDE analysis
                document.getElementById('asymmetryResult').textContent = 
                    analysisNotes.symmetry === 'asymmetric' ? 'Potentially asymmetric' : 'Appears symmetric';
                
                document.getElementById('borderResult').textContent = 
                    analysisNotes.border === 'irregular' ? 'Potentially irregular' : 'Appears regular';
                
                document.getElementById('colorResult').textContent = 
                    analysisNotes.colorVariation === 'high' ? 'Multiple colors detected' : 
                    (analysisNotes.colorVariation === 'medium' ? 'Some color variation' : 'Uniform color');
                
                document.getElementById('diameterResult').textContent = analysisNotes.diameter;
                
                // Show result
                loadingAnalysis.style.display = 'none';
                analysisResult.style.display = 'block';
                
            } catch (error) {
                console.error('Error during analysis:', error);
                
                // Fallback to random result if analysis fails
                loadingAnalysis.style.display = 'none';
                
                // Select a random condition for fallback
                const fallbackCondition = SKIN_CONDITIONS[Math.floor(Math.random() * SKIN_CONDITIONS.length)];
                
                // Format condition name for display
                const formattedCondition = fallbackCondition.term
                    .split(' ')
                    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                    .join(' ');
                
                // Prepare fallback result
                let displayResult;
                if (fallbackCondition.risk === 'high') {
                    displayResult = {
                        icon: '🚨',
                        message: `High Risk - Possible ${fallbackCondition.term}`,
                        concern: 'High',
                        concernClass: 'risk-high',
                        recommendation: 'Seek medical attention',
                        timeFrame: 'As soon as possible'
                    };
                } else if (fallbackCondition.risk === 'medium') {
                    displayResult = {
                        icon: '⚠️',
                        message: `Medium Risk - Possible ${fallbackCondition.term}`,
                        concern: 'Medium',
                        concernClass: 'risk-medium',
                        recommendation: 'Consult with a dermatologist',
                        timeFrame: 'Within the next 2 weeks'
                    };
                } else {
                    displayResult = {
                        icon: '✅',
                        message: `Low Risk - Possible ${fallbackCondition.term}`,
                        concern: 'Low',
                        concernClass: 'risk-low',
                        recommendation: 'Monitor for changes',
                        timeFrame: 'No immediate action needed'
                    };
                }
                
                // Update main result display
                resultIcon.textContent = displayResult.icon;
                resultMessage.textContent = displayResult.message + ' (Fallback Mode)';
                concernLevel.textContent = displayResult.concern;
                concernLevel.className = displayResult.concernClass;
                recommendation.textContent = displayResult.recommendation;
                timeFrame.textContent = displayResult.timeFrame;
                
                // Update confidence score (lower in fallback mode)
                document.getElementById('confidenceScore').textContent = '40';
                
                // Update possible condition
                document.getElementById('possibleCondition').textContent = formattedCondition + ' (Fallback Mode)';
                
                // Update ABCDE analysis with fallback data
                document.getElementById('asymmetryResult').textContent = 'Unable to determine';
                document.getElementById('borderResult').textContent = 'Unable to determine';
                document.getElementById('colorResult').textContent = 'Unable to determine';
                document.getElementById('diameterResult').textContent = 'Unable to determine';
                
                // Show result
                analysisResult.style.display = 'block';
            }
        });
    </script>
</body>
</html>